#!/usr/bin/env python3
#
# fixPairs.py: Try to fix common OCR errors.
# 2015-08-25: Written by Steven J. DeRose.
#
import sys
import argparse
import re
import codecs
from collections import defaultdict

import logging
lg = logging.getLogger()

__metadata__ = {
    "title"        : "fixPairs",
    "description"  : "Try to fix common OCR errors.",
    "rightsHolder" : "Steven J. DeRose",
    "creator"      : "http://viaf.org/viaf/50334488",
    "type"         : "http://purl.org/dc/dcmitype/Software",
    "language"     : "Python 3.7",
    "created"      : "2015-08-25",
    "modified"     : "2021-03-03",
    "publisher"    : "http://github.com/sderose",
    "license"      : "https://creativecommons.org/licenses/by-sa/3.0/"
}
__version__ = __metadata__["modified"]

typesByPair = defaultdict(int)
tokensByPair = defaultdict(int)
pairExamples = defaultdict(list)

splitExpr = re.compile(r'\t')


descr = """
=Description=

Utility to help figure out what character-mappings to use for OCR correction.
Obvious cases include 0->O, c->e, rn->m, and f->s (for texts prior to ~1800).

But the more mappings, the more collisions may occur (where
a single erroneous (well, unknown) form, maps to more than one correct (known)
form.

This scans a file of found->fixed corrections, and see what the diffs.


=Known bugs and Limitations=

Should add a feature to scan a corpus, and see how many rule-collisions
come up with various maps (e.g., whether a rare case like 6->c introduces
a lot of cases where a given error could map to >1 real (fixed) word.

Hook up to C<SimplifyUnicode> to ascii-ize, strip accents, etc.
Cf. https://pypi.python.org/pypi/Unidecode.

    from unidecode import unidecode
    asc = unidecode(u)


=History=

  2015-08-25: Written by Steven J. DeRose.


=Rights=

Copyright %DATE% by Steven J. DeRose. This work is licensed under a
Creative Commons Attribution-Share-alike 3.0 unported license.
For further information on this license, see
[https://creativecommons.org/licenses/by-sa/3.0].

For the most recent version, see [http://www.derose.net/steve/utilities]
or [https://github.com/sderose].


=Options=
"""


"""Table of corrections generated by this program
   running on BestLcOCRRules.txt (a dictionary, not a text).
   We only use pairs representing at least args.minvocab forms.
   'Types' here represents how many types (of ~50,000 in the file)
   represent a single-character change, from char 1 to char 2.
"""
pairMap = [
    #Found  Fixed     Types
    ("f",   "s",    17104),
    ("c",   "e",    14945),
    ("1",   "i",     3116),
    ("v",   "y",     2791),
    ("l",   "t",     1823),
    ("b",   "h",     1166),
    ("1",   "l",      943),
    ("6",   "e",      838),
    ("l",   "s",      823),
    ("f",   "c",      646),
    ("l",   "i",      546),
    ("0",   "o",      442),
    ("d",   "c",      328),
    ("6",   "o",      290),
    ("e",   "c",      158),
    ("c",   "o",      147),
    ("j",   "s",      141),
    ("i",   "l",      115),
    ("j",   "y",       67),
    ("i",   "s",       46),
    ("y",   "v",       46),
    ("3",   "s",       41),
    ("8",   "s",       27),
    ("5",   "s",       24),
    ("f",   "e",       22),
    ("d",   "e",       15),
    ("o",   "c",       10),
    ("4",   "e",        9),
    ("7",   "y",        7),
    ("3",   "e",        7),
    ("c",   "f",        7),
    ("3",   "d",        6),
    ("9",   "g",        6),
    ("9",   "a",        4),
    ("2",   "z",        3),
    ("4",   "t",        3),
    ("3",   "o",        2),
    ("t",   "l",        2),
    ("i",   "t",        2),
    ("y",   "j",        1),
    ("8",   "g",        1),
    ("6",   "c",        1),
]


###############################################################################
#
def processOptions():
    try:
        from BlockFormatter import BlockFormatter
        parser = argparse.ArgumentParser(
            description=descr, formatter_class=BlockFormatter)
    except ImportError:
        parser = argparse.ArgumentParser(description=descr)

    parser.add_argument(
        "--iencoding", type=str, metavar='E', default="utf-8",
        help='Assume this character set for input files. Default: utf-8.')
    parser.add_argument(
        "--ignoreCase", "-i", action='store_true',
        help='Disregard case distinctions.')
    parser.add_argument(
        "--minvocab", type=int, default=25,
        help='Trim list or single-char mappings to use, to ones that ' +
        'represent at least this many vocab items.')
    parser.add_argument(
        "--quiet", "-q", action='store_true',
        help='Suppress most messages.')
    parser.add_argument(
        "--verbose", "-v", action='count', default=0,
        help='Add more messages (repeatable).')
    parser.add_argument(
        "--version", action='version', version=__version__,
        help='Display version information, then exit.')

    parser.add_argument(
        'files', type=str, nargs=argparse.REMAINDER,
        help='Path(s) to input file(s)')

    args0 = parser.parse_args()
    if (lg and args0.verbose):
        logging.basicConfig(level=logging.INFO - args0.verbose,
            format="%(message)s")

    if (len(args0.files)==0):
        args0.files.append("BestLcOCRRules.txt")

    return(args0)


###############################################################################
#
stats = defaultdict(int)

def doOneFile(path:str):
    recnum = 0
    rec = ""
    try:
        fh = codecs.open(path, mode='r', encoding=args.iencoding)
    except IOError:
        lg.error("Can't open '%s'.", path); stats["CantOpen"] += 1
        return(0)
    while (True):
        try:
            rec = fh.readline()
        except IOError as e:
            lg.error("Error (%s) reading record %d of '%s'.",
                type(e), recnum, path); stats["readError"] += 1
            break
        if (len(rec) == 0): break # EOF
        recnum += 1
        rec = rec.rstrip()
        tokens = re.split(splitExpr, rec)
        if (len(tokens)!=3):
            print("%d: Wrong number of fields (%d) in '%s'",
                recnum, len(tokens), rec)
            continue
        found, fixed, freq = tokens
        freq = int(freq)
        stats['totalFreq'] += freq
        if (len(found) != len(fixed)):
            lg.info("%s\tLength mismatch", rec)
            stats["typesLengthDifference"] += 1
            stats['tokensLengthDifference'] += freq
            continue

        d = 0
        while(found[d]==fixed[d]): d += 1
        w = found[d]
        c = fixed[d]

        # Now try to fix
        if (d==len(found)-1):
            typesByPair[(w,c)] += 1
            tokensByPair[(w,c)] += freq
            pairExamples[(w,c)].append(found)
        elif (found[d+1:]==fixed[d+1:]):
            typesByPair[(w,c)] += 1
            tokensByPair[(w,c)] += freq
            pairExamples[(w,c)].append(found)
        elif (re.sub(r'f', 's', found)==fixed):
            stats['multiFS'] += 1
        elif (tryList(found, fixed)):
            stats['byList'] += 1
        else:
            stats['other'] += 1
    fh.close()
    report(recnum)
    return(recnum)

def tryList(found, fixed) -> bool:
    """Try the corrections in the list, vs. a dictionary, and collect all
    the returns.
    """
    for _i, pair in enumerate(pairMap):
        fr, to, _freq = pair
        if (re.sub(fr,to,found) == fixed):
            return(True)
    return(False)

def report(recnum:int):
    sigma = "\u03A3"
    print("Forms in list, that need one-character replacement:")
    print("      Err   Fix    Tokens     Tokens%       " + sigma +
        "tok%    Types      Types%       " + sigma + "typ%")
    fmt = "    %s %8d %10.4f%% %10.4f%% %8d %10.4f%% %10.4f%%"

    stokPct = 0.0
    stypPct = 0.0
    skey = sorted(tokensByPair.items(), key=lambda x: -x[1])
    for k in skey:
        pair, _freq = k
        tokFreq = tokensByPair[pair]
        tokPct = tokFreq*100.0/stats['totalFreq']
        stokPct += tokPct
        typFreq = typesByPair[pair]
        typPct = typFreq*100.0/recnum
        stypPct += typPct
        msg = fmt % (pair, tokFreq, tokPct, stokPct, typFreq, typPct, stypPct)
        lim = min(5, len(pairExamples[k]))
        if (args.verbose): msg += str(pairExamples[k][0:lim])
        print(msg)


###############################################################################
# Main
#
args = processOptions()

if (len(args.files) == 0):
    lg.error("No files specified....")
    sys.exit()

for f in (args.files):
    stats["totalFiles"] += 1
    recs = doOneFile(f)
    stats["totalRecords"] += recs
