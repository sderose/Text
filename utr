#!/usr/bin/perl -w
#
# Make a 'tr' that works for Unicode.  
#
# 2010-06-03: Written by Steven J. DeRose.
# 
# To do:
#
use strict;
use Getopt::Long;

our $VERSION_DATE = "2012-09-12";

my $e = ""; # error-message prefix
my $MaxUnicode = 0xFFFD; # for now....

my $complement    = 0;
my $delete        = 0;
my $force         = 0;
my $iencoding     = "";
my $ilineends     = "U";
my $lc            = 0;
my $oencoding     = "";
my $olineends     = "U";
my $quiet         = 0;
my $squeeze       = 0;
my $truncate      = 0;
my $uc            = 0;
my $verbose       = 0;
my $xml           = 0;


###############################################################################
#
Getopt::Long::Configure ("ignore_case");
my $result = GetOptions(
    "complement!"             => \$complement,
    "delete!"                 => \$delete,
    "force!"                  => \$force,
    "h|help"                  => sub {
        system "perldoc $0";
        exit;
    },
    "iencoding=s"             => \$iencoding,
    "ilineends=s"             => \$ilineends,
    "lc!"                     => \$lc,
    "oencoding=s"             => \$oencoding,
    "olineends=s"             => \$olineends,
    "q!"                      => \$quiet,
    "squeeze!"                => \$squeeze,
    "truncate-set1!"          => \$truncate,
    "uc!"                     => \$uc,
    "v+"                      => \$verbose,
    "version"                 => sub {
        die "Version of $VERSION_DATE, by Steven J. DeRose.";
    },
    "xml!"                    => \$xml,
    );

($result) || die "Bad options.\n";

(scalar @ARGV > 0) || die "No set of characters specified.\n";
my $set1 = shift;
my $set2 = (scalar @ARGV > 0) ? shift:"";

my $tr1 = setup($set1);
my $tr2 = setup($set2);

if ($truncate) {
    if (length($tr1) > length($tr2)) {
        $tr1 = substr($tr1,0,length($tr2));
    }
}


###############################################################################
###############################################################################
# Main
#

# Perl tr/// supports most of the 'tr' flags, so just pass then on.
#
my $flags = "";
if ($complement) { $flags .= "c"; } 
if ($squeeze)    { $flags .= "s"; } 
if ($delete)     { $flags .= "d";
    if ($tr2 ne "") { warn "Warning: -d specified with [set2]\n"; }
}

if ($verbose) {
    warn "set1 came out to: '$tr1'\n";
    warn "set2 came out to: '$tr2'\n";
}

# Check for odd translations and warn...
#
if (!$quiet) {
    my $mixed = 0;
    my $min = length($tr1);
    if (length($tr2) < $min) { $min = length($tr2); }
    for (my $i=0; $i<$min; $i++) {
        my $c1 = substr($tr1,$i,1);
        my $c2 = substr($tr2,$i,1);
        my $isAlpha1 = (lc($c1) ne uc($c1)) ? 1:0;
        my $isAlpha2 = (lc($c2) ne uc($c2)) ? 1:0;
        if ($isAlpha1 != $isAlpha2) {
            warn sprintf("Warning: letter/non-letter translation:\n" .
                         "    set1: '%s' (x%x, d%d), set2: '%s' (x%x, d%d).\n",
                         $c1, ord($c1), ord($c1), $c2, ord($c2), ord($c2)); 
            $mixed++;
        }
    } # for
    if ($mixed) {
        warn "\n*** Total of $mixed letter/non-letter translations ***\n";
        if (!$force) {
            die "    To run anyway, add the -f option.\n";
        }
    }
}

# Now escape the character-lists for use in regexes
#     (but keep the Posix character-class expressions)
#
$tr1 =~ s/([^[\]:a-zA-Z0-9])/\\$1/g;
$tr2 =~ s/([^[\]:a-zA-Z0-9])/\\$1/g;

if ($verbose) {
    warn "set1 came out to: '$tr1'\n";
    warn "set2 came out to: '$tr2'\n";
}


###############################################################################
# Set implied options, validate option values...

my $fh;
my $file = shift;
if ($file) {
    (-f $file) || die "Can't find input file '$file'.\n";
}
else {
	($quiet) || warn "Reading from stdin...\n";
    $file = "-";
}

open $fh, "<$file" || die "Failed to open input file '$file'.\n";

$ilineends = uc(substr($ilineends."U",0,1));
if    ($ilineends eq "M") { $/ = chr(13); }
elsif ($ilineends eq "D") { $/ = chr(13).chr(10); }
else { }

$olineends = uc(substr($olineends."U",0,1));
if    ($olineends eq "M") { $\ = chr(13); }
elsif ($olineends eq "D") { $\ = chr(13).chr(10); }
else { }


###############################################################################
#
my $recnum = 0;
while (my $rec = <$fh>) {
    $recnum++;
    chomp $rec;
    if ($lc) {
        $rec = lc($rec);
    }
    elsif ($uc) {
        $rec = uc($rec);
    }
    else {
        $_ = $rec;
        eval "tr/$tr1/$tr2/$flags"; # otherwise won't deal with variables
        $rec = $_;
    }
    print "$rec\n";
}

($quiet) || warn "Done, $recnum records processed.\n";

exit;



###############################################################################
###############################################################################
# Interpret all the stuff that can happen inside one of the users character
# lists, so it becomes a string of just literal characters.
#
sub setup {
    my $set = $_[0];
    ($set eq "") && return("");
    my $buf = "";
    for (my $i=0; $i<length($set); $i++) {
        my $c = substr($set,$i,1);
        my $c2 = ($i<length($set)-1)
            ? substr($set,$i+1,1) : ""; # lookahead
        my $rest = substr($set,$i);

        if ($c eq "\\") {                    # backslash-codes
            ($verbose) && warn "Backslash code at '$rest'\n";
            $i++;
            my $c2 = substr($set,$i,1);
            if    ($c2 eq "\\") { $buf .= "\\"; }
            elsif ($c2 eq "a")  { $buf .= chr(7); }
            elsif ($c2 eq "b")  { $buf .= chr(8); }
            elsif ($c2 eq "e")  { $buf .= chr(27); }
            elsif ($c2 eq "f")  { $buf .= chr(12); }
            elsif ($c2 eq "n")  { $buf .= chr(10); }
            elsif ($c2 eq "r")  { $buf .= chr(13); }
            elsif ($c2 eq "t")  { $buf .= chr(9); }
            elsif ($c2 eq "v")  { $buf .= chr(11); }
            elsif ($c2 eq "-")  { $buf .= chr(45); }
            elsif (substr($set,$i) =~ m/^[0-7][0-7][0-7]/)  {
                $buf .= substr($set,0,3);
            }
            else {
                warn "Unknown code '\\$c2', treated as '$c2'.\n";
                $buf .= $c2;
            }
        }
        # ICK: this lets you specify start of range as \ or entity,
        # but not end of range. Probably not worth fixing in short term.
        #
        elsif ($c eq "-") {                  # character range   
            ($verbose) && warn "Range at '$rest'\n";
            $i++;
            (my $last = $buf) =~ s/.*(.)$/$1/;
            my $o = ord($last); my $o2 = ord($c2);
            ($o2 > $o) || die "Hyphen range is out of order ($o - $o2).\n";
            if (!(($last =~ m/[[:lower:]]/ && $c2 =~ m/[[:lower:]]/) ||
                  ($last =~ m/[[:upper:]]/ && $c2 =~ m/[[:upper:]]/) ||
                  ($last =~ m/[[:digit:]]/ && $c2 =~ m/[[:digit:]]/))) {
                warn "Warning: Range not digits or uniform case:" .
                    " '$last'-'$c2'\n";
            }
            for (my $i=$o+1; $i<=$o2; $i++) {
                $buf .= chr($i);
            }
        }
        elsif ($c eq "[") {                  # posix character class
            if (substr($set,$i) =~ m/\[:([a-z]+):]/) {
                my $members = getPosixClassMembers($1);
                if ($members eq "") {
                    die "Unknown Posix character class '$1'\n";
                }
                $buf .= $members;
            }
            else {
                warn "Found '[' not starting a Posix character class ref.\n";
                $buf .= $c;
            }
        }
        elsif ($xml && $c eq "&") {          # XML-style entity
            if (substr($set,$i) =~ m/&#x([0-9a-f]+);/i) {   # hex
                $buf .= chr(hex($1));
                $i += length($1)+3;
            }
            elsif (substr($set,$i) =~ m/&#([0-9]+);/) {     # dec
                $buf .= chr($1 - 0);
                $i += length($1)+2;
            }
        }
        else {                               # literal character
            $buf .= $c;
        }
    } # for each character
    return($buf);
}


###############################################################################
# Has to be a quicker way to do this....
# Note that Unicode upper/lower case inventories aren't 1:1. 
# makeUnicodeData shows 800 lowercase, and only 691 uppercase.
# So we generate upper by generating lower and then translating.
# This may or may not be what you want....
#
sub getPosixClassMembers {
    my $name = $_[0];
    my $rec = "alnum|alpha|blank|cntrl|digit|graph|lower|print|"
        . "punct|space|upper|xdigit";
    if ($name !~ m/^($rec)$/) { return(""); }
    my $isLower = ($rec eq "lower") ? 1:0;
    if ($isLower) { $rec = "upper"; } # Ensure upper/lower lists sync up.
    my $buf = "";
    for (my $i=1; $i<$MaxUnicode; $i++) {
        if ($i==0xd800) { $i = 0xdfff; next; }
        if ($i==0xFDD0) { $i = 0xFDFF; next; }
        if (chr($i) =~ m/[[:$name:]]/) { $buf .= chr($i); }
    }
    if ($isLower) { $buf = lc($buf); }
    ($verbose) && warn "Expanded Posix class '$name' into " . length($buf) .
        " characters.\n";
    return($buf);
}



###############################################################################
###############################################################################
###############################################################################
#

=pod

=head1 Usage

utr [options] [set1] [set2] file

A version of 'tr' that has a clue about Unicode.
See http://unicode.org/Public/UNIDATA/CaseFolding.txt for information on
the vagaries of Unicode case-translation (note that you can do case-translation
with the script either by specifying character lists, character ranges,
character classes, or just -lc/-uc (author prefers the last of those; they
aren't all quite the same).

You will get warnings for some likely-erroneous translations, such as
translating letters to non-letters or vice-versa, or using unknown backslash
codes.



=head1 The [set1] and [set2] arguments

set1 specifies a sequence of characters to be translated (or with -delete,
deleted). set2 specifies a list of target characters, such that the nth
characters of set1 will be translated into the nth character of list2.
Characters can be specified literally, or using the following shorthands.
 
=head2 Backslash escapes

(a few more than with traditional 'tr'):
       \     backslash
       a     audible BEL
       b     backspace
       e     escape (not in traditional tr)
       f     form feed
       n     new line
       r     return
       t     horizontal tab
       v     vertical tab
       -     hyphen (not in traditional tr)
       NNN   where NNN means 3 octal digits (000-777)
       xFFFF where FFFF means 4 hex digits  (not in traditional tr)

=head2 Unicode characters above xFFFF

For characters above 0xFFFF, see the -xml option below.


=head2 Posix character classes

The names listed below are supported,
and defined with respect to Unicode. The character list for each class
is determined on the fly (by searching the Unicode space for characters in
the given class), so may take a few seconds each.

       [:alnum:]
       [:alpha:]
       [:blank:]
       [:cntrl:]
       [:digit:]
       [:graph:]
       [:lower:]
       [:print:]
       [:punct:]
       [:space:]
       [:upper:]
       [:xdigit:]

If you use an unknown class name, the script will die.

=head2 Ranges

char1-char2 (although 'man tr' doesn't say so, hyphen is literal if at
the *end* of a list; here you can also backslash it).

(char* and char*n not supported)

Unlike 'tr', all such classes are guaranteed to be expanded in numerical
(code point) order.



=head1 Options

(prefix 'no' to negate where applicable)

=over 

=item B<--complement>

Complement set1

=item B<--delete>

Deletes characters in [set1].

=item B<--force>

Run even if some ranges do not map between
lettes and letters, or digits and digits (anything else may be risky
depending on the character set; then again, if it's not Unicode the script
may not detect the problem correctly; but if it's because set1 and set2 got
out of sync with each other, the warning may save you some trouble. 

=item B<--ilineends> I<t>

Assume Unix, Dos, or Mac line-breaks for input.

=item B<--lc>

Just translate upper to lower case; other options
are mostly ignored. This just does whatever Perl lc() does.

=item B<--olineends> I<t>

Write Unix, Dos, or Mac line-breaks for output.

=item B<-q>

Suppress most messages.

=item B<-s> or B<--squeeze-repeats>
replace each input sequence of a repeated character that is
listed in SET1 with a single occurrence of that character

=item B<--truncate-set1>

First truncate SET1 to length of SET2

=item B<--uc>

Just translate lower to upper case; other options
are mostly ignored. This just does whatever Perl uc() does.

=item B<-v>

Add more messages (repeatable), including a display
of what [set1] and [set2] expanded to (after backslashing, ranges,
octal or other numeric references).

=item B<--version>

Show version/license info and exit.

=item B<--xml>

Allow XML-style numeric character reference in set1
and set2. For example, &#xDEADBEEF;.

=back



=head1 Known Bugs/Limitations

Unicode has more upper than lower case characters,
so the mapping generated here is a little weird -- [:lower:] is generated by
retrieving all the *upper* case Unicode chars, then forcing them to lower case.
This may or not be the result you want... (suggestions for improvement welcome).

Unicode title-case characters (e.g., U01c5, U01c8, U01cb, U01f2)
are not supported in any special way (for example, with [:lower:] and [:upper:].
Nor is the infamous dotless 'i'. No Unicode normalization is done either.

You can specify the start of a range (like a-z) using a backslash code or 
XML-style character reference, but you cannot do that for the end of range.
This is annoying.



=head1 Related commands

makeUnicodedata -- can extract a table of Unicode characters with various
properties; handy for finding the characters you need.



=head1 Ownership

This work by Steven J. DeRose is licensed under a Creative Commons 
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/>.

For the most recent version, see L<http://www.derose.net/steve/utilities/>.

=cut
